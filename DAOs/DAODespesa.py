#######################################################
# 
# DAODespesa.py
# Python implementation of the Class DAODespesa
# Generated by Enterprise Architect
# Created on:      15-Apr-2024 9:30:53 PM
# Original author: rlnet
# 
#######################################################
import os, pickle
from DAOs.DAO import DAO
from entidades.Despesa import Despesa

class DAODespesa(DAO):
    def __init__(self, arquivo: str):
        self.__arquivo = arquivo
        self._DAODespesa__conteudo = []
        if os.path.exists(self.__arquivo):
            try:
                self._DAODespesa__conteudo = self.__load()
            except FileNotFoundError:
                self.__dump()
                self.__load()

    @property
    def conteudo(self) -> list:
        return self._DAODespesa__conteudo

    @conteudo.setter
    def conteudo(self, valor: list):
        self._DAODespesa__conteudo = valor

    # tipos?
    def create(self, id: int, obs: str, valor: float, data: str, imovel, tags: list[str]) -> bool:
        tamanho = len(self.conteudo)
        nova_despesa = Despesa(ident=id, obs=obs, valor=valor, data=data, imovel=imovel, tags=tags)
        self.conteudo.append(nova_despesa)
        print("Despesa criada com sucesso:")
        print(f"ID: {nova_despesa.id}")
        print(f"Observação: {nova_despesa.obs}")
        print(f"Valor: {nova_despesa.valor}")
        print(f"Data: {nova_despesa.data}")
        print(f"Imóvel: {nova_despesa.imovel}")
        print(f"Tags: {nova_despesa.tags}")
        self.__dump()
        self.__load()
        if len(self.conteudo) > tamanho:
            return True
        else:
            return False

    # ?? habilitado
    def delete(self, id: int) -> bool:
        for i in range(len(self.conteudo)):
            if self.conteudo[i].id == id:
                del self.conteudo[i]
                self.__dump()
                self.__load()
                return True
        return False

    def read(self) -> list:
        return [despesa for despesa in self.conteudo]

    def update(self, id: int, nova_obs: str, novo_valor: float, nova_data: str, novo_imovel, nova_tags: list[str]) -> bool:
        for i in range(len(self.conteudo)):
            if self.conteudo[i].id == id:
                self.conteudo[i].obs = nova_obs
                self.conteudo[i].valor = novo_valor
                self.conteudo[i].data = nova_data
                self.conteudo[i].imovel = novo_imovel
                self.conteudo[i].tags = nova_tags
                self.__dump()
                self.__load()
                return True
        return False

    def __dump(self):
        with open(self.__arquivo, 'wb') as arquivo:
            pickle.dump(self.conteudo, arquivo)

    def __load(self):
        with open(self.__arquivo, 'rb') as arquivo:
            self.conteudo = pickle.load(arquivo)
        return self.conteudo